# Architecture Validation Playbook

**Purpose**: Validate Clean Architecture compliance (dependency rules).

**When to use**: Before commits, after implementing new layers/modules.

---

## IMPORTANT: Read Reporting Guidelines FIRST

**BEFORE executing this playbook**, read: `.workflow/playbooks/reporting-guidelines.md`

You MUST announce validation progress layer-by-layer to keep the user informed.

---

## Step 0: Announce Validation Start

**Report to user**:
```
ğŸ›ï¸ Architecture Validation

Executing: .workflow/playbooks/architecture-check.md

Validating Clean Architecture compliance:
- Domain layer (no dependencies)
- Application layer (domain only)
- Infrastructure layer (app + domain)
- Presentation layer (app + domain, NOT infra)

Let's begin...
```

---

## Clean Architecture Principles

### The Dependency Rule

**Dependencies must point INWARD only** (toward the domain).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frameworks & Drivers              â”‚
â”‚   (Web, DB, UI, Devices, etc.)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–²
      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Interface Adapters                â”‚
â”‚   (Controllers, Presenters, Gateways)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–²
      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application (Use Cases)           â”‚
â”‚   (Application Business Rules)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–²
      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Domain (Entities/Interfaces)      â”‚
â”‚   (Enterprise Business Rules)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Each layer can only depend on the layers immediately inside it.

### Allowed Dependencies

From `.workflow/config.yml`:

| Layer | Can Depend On |
|-------|---------------|
| Domain | Nothing (pure ${LANGUAGE}) |
| Application | Domain only |
| Infrastructure | Application + Domain |
| Presentation | Application + Domain (NOT Infrastructure) |
| DI | All layers (wires everything) |

---

## Step 1: Read Project Structure

**Report to user**:
```
## Step 1: Reading Project Structure

Identifying layer directories and source files...
```

### 1.1 Identify Layer Directories

```bash
ls -la ${SOURCE_DIR}/
```

Expected structure:
```
${SOURCE_DIR}/
â”œâ”€â”€ domain/          # Pure business logic
â”œâ”€â”€ application/     # Use cases
â”œâ”€â”€ infrastructure/  # Implementations
â”œâ”€â”€ presentation/    # Controllers, routes
â””â”€â”€ di/              # Dependency injection
```

### 1.2 List All Source Files

```bash
find ${SOURCE_DIR}/ -name "${FIND_FILES_PATTERN}" -type f
```

Note all files in each layer.

**Report to user after reading structure**:
```
âœ… Step 1 Complete: Project Structure Identified

Layers found:
- Domain: {count} files
- Application: {count} files
- Infrastructure: {count} files
- Presentation: {count} files
- DI: {count} files

Next: Step 2 - Check Domain Layer
```

---

## Step 2: Check Domain Layer (No Dependencies)

**Report to user**:
```
## Step 2: Checking Domain Layer

Validating: Domain has no dependencies on other layers...
```

### 2.1 Find All Domain Files

```bash
find ${DOMAIN_PATH}/ -name "${FIND_FILES_PATTERN}" -type f
```

### 2.2 Check Imports in Domain Files

For each domain file, check imports:

```bash
grep -n "${IMPORT_PATTERN}" ${DOMAIN_PATH}/**/*${FILE_EXTENSION}
```

**Validation Rules**:

âœ… **Allowed in Domain**:
- No imports from other project layers
- Only ${LANGUAGE} built-ins
- Only type imports (if truly needed)

âŒ **NOT Allowed in Domain**:
- Imports from \`application/\`
- Imports from \`infrastructure/\`
- Imports from \`presentation/\`
- Imports from \`di/\`
- External libraries (except pure type definitions)

**Example**:
\`\`\`${LANGUAGE_LOWER}
// âœ… ALLOWED in Domain
${EXAMPLE_CLASS}
  id: string
  name: string
  email: string
}

// âŒ NOT ALLOWED in Domain
${EXAMPLE_IMPORT} // From application layer - violates rule
```

### 2.3 Report Domain Violations

**If violations found**:
```
âŒ Domain Layer: {count} Violations

File: ${DOMAIN_PATH}/User${FILE_EXTENSION}
Line 3: ${EXAMPLE_IMPORT}
Reason: Domain cannot depend on Application layer

Action required:
- Remove the import
- Move shared code to Domain
- Use dependency injection instead
```

**If no violations**:
```
âœ… Domain Layer: Clean

All {count} domain files validated.
No dependencies on other layers. âœ…

Next: Step 3 - Check Application Layer
```

---

## Step 3: Check Application Layer (Domain Only)

**Report to user**:
```
## Step 3: Checking Application Layer

Validating: Application depends only on Domain...
```

### 3.1 Find All Application Files

```bash
find ${APPLICATION_PATH}/ -name "${FIND_FILES_PATTERN}" -type f
```

### 3.2 Check Imports in Application Files

```bash
grep -n "${IMPORT_FROM_PATTERN}" ${APPLICATION_PATH}/**/*${FILE_EXTENSION}
```

**Validation Rules**:

âœ… **Allowed in Application**:
- Imports from \`domain/\`
- ${LANGUAGE} built-ins
- Pure libraries (no framework-specific code)

âŒ **NOT Allowed in Application**:
- Imports from \`infrastructure/\`
- Imports from \`presentation/\`
- Imports from \`di/\`
- Framework imports (Express, etc.)

**Example**:
\`\`\`${LANGUAGE,,}
// âœ… ALLOWED in Application
${EXAMPLE_IMPORT}

${EXAMPLE_CLASS}
  // Uses dependency injection for repository
}

// âŒ NOT ALLOWED in Application
// Importing from infrastructure layer violates dependency rule
```

### 3.3 Report Application Violations

**If violations found**:
```
âŒ Application Layer: {count} Violations

File: ${APPLICATION_PATH}/GetUsers${FILE_EXTENSION}
Line 5: import { Repository } from '../infrastructure/...'
Reason: Application cannot depend on Infrastructure layer

Action required:
- Use interface (UserRepository) instead
- Inject concrete implementation via DI
```

**If no violations**:
```
âœ… Application Layer: Clean

All {count} application files validated.
Only depends on Domain. âœ…

Next: Step 4 - Check Infrastructure Layer
```

---

## Step 4: Check Infrastructure Layer (Application + Domain)

**Report to user**:
```
## Step 4: Checking Infrastructure Layer

Validating: Infrastructure depends only on Application + Domain...
```

### 4.1 Find All Infrastructure Files

```bash
find ${INFRASTRUCTURE_PATH}/ -name "${FIND_FILES_PATTERN}" -type f
```

### 4.2 Check Imports

```bash
grep -n "${IMPORT_FROM_PATTERN}" ${INFRASTRUCTURE_PATH}/**/*${FILE_EXTENSION}
```

**Validation Rules**:

âœ… **Allowed in Infrastructure**:
- Imports from \`domain/\`
- Imports from \`application/\`
- External libraries
- Framework code (Express, databases, etc.)

âŒ **NOT Allowed in Infrastructure**:
- Imports from \`presentation/\`
- Imports from \`di/\`

**Example**:
\`\`\`${LANGUAGE,,}
// âœ… ALLOWED in Infrastructure
${EXAMPLE_IMPORT}

${EXAMPLE_CLASS}
  // Implements domain interface
}

// âŒ NOT ALLOWED in Infrastructure
// Importing from presentation layer violates dependency rule
```

**If no violations**:
```
âœ… Infrastructure Layer: Clean

All {count} infrastructure files validated.
Only depends on Application + Domain. âœ…

Next: Step 5 - Check Presentation Layer
```

---

## Step 5: Check Presentation Layer (Application + Domain)

**Report to user**:
```
## Step 5: Checking Presentation Layer

Validating: Presentation depends only on Application + Domain (NOT Infrastructure)...
```

### 5.1 Find All Presentation Files

```bash
find ${PRESENTATION_PATH}/ -name "${FIND_FILES_PATTERN}" -type f
```

### 5.2 Check Imports

```bash
grep -n "${IMPORT_FROM_PATTERN}" ${PRESENTATION_PATH}/**/*${FILE_EXTENSION}
```

**Validation Rules**:

âœ… **Allowed in Presentation**:
- Imports from \`domain/\`
- Imports from \`application/\`
- Framework imports (Express Request/Response)

âŒ **NOT Allowed in Presentation**:
- Imports from \`infrastructure/\` (CRITICAL)
- Imports from \`di/\`

**Example**:
\`\`\`${LANGUAGE,,}
// âœ… ALLOWED in Presentation
${EXAMPLE_IMPORT}

${EXAMPLE_CLASS}
  // Uses application layer use case
}

// âŒ NOT ALLOWED in Presentation
// Importing from infrastructure layer - most common violation!
```

**This is the most common violation** - Presentation should NEVER import from Infrastructure directly.

**If violations found**:
```
âŒ Presentation Layer: {count} Violations

File: ${PRESENTATION_PATH}/UserController${FILE_EXTENSION}
Line 2: import { Repository } from '../infrastructure/...'
Reason: Presentation cannot depend on Infrastructure layer (most common violation!)

Action required:
- Remove Infrastructure imports
- Use Use Cases (Application layer) instead
- Inject dependencies via DI layer
```

**If no violations**:
```
âœ… Presentation Layer: Clean

All {count} presentation files validated.
Only depends on Application + Domain. âœ…
No Infrastructure dependencies found. âœ…

Next: Step 6 - Generate Validation Report
```

---

## Step 6: Generate Validation Report

**Report to user**:
```
## Step 6: Generating Validation Report

Summarizing findings across all layers...
```

### 6.1 Summarize Findings

Collect all violations from Steps 2-5.

### 6.2 Count Violations by Type

```
Architecture Validation Report
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Violations by Layer:
- Domain: {count}
- Application: {count}
- Infrastructure: {count}
- Presentation: {count}

Total Violations: {total}
```

### 6.3 Provide Detailed Report

For each violation:
```
Violation #{number}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Layer: {layer name}
File: {file path}:{line number}
Code: {import statement}
Rule: {which rule violated}
Fix: {how to fix}
```

---

## Step 7: Pass/Fail Decision

### If Zero Violations:

**Report to user**:
```
âœ… Architecture Validation PASSED

Clean Architecture Compliance: 100%

Layer Results:
âœ… Domain ({file_count} files): No dependencies
âœ… Application ({file_count} files): Domain only
âœ… Infrastructure ({file_count} files): Application + Domain
âœ… Presentation ({file_count} files): Application + Domain

Total Violations: 0

All layers respect dependency rules. âœ…
```

**Exit code: 0**

### If Any Violations:

**Report to user**:
```
âŒ Architecture Validation FAILED

Total Violations: {count}

Layer Results:
{Show each layer with violation count}

Cannot proceed - fix violations before committing.

See detailed violation reports above for specific issues and fixes.
```

**Exit code: 1**

---

## Common Violations and Fixes

### Violation 1: Presentation imports Infrastructure

\`\`\`${LANGUAGE,,}
// âŒ WRONG
// ${PRESENTATION_PATH}/UserController${FILE_EXTENSION}
// Importing repository directly from infrastructure

// âœ… CORRECT
// ${PRESENTATION_PATH}/UserController${FILE_EXTENSION}
// Use application layer use case instead
\`\`\`

**Fix**: Use dependency injection

### Violation 2: Application imports Infrastructure

\`\`\`${LANGUAGE,,}
// âŒ WRONG
// ${APPLICATION_PATH}/GetUsers${FILE_EXTENSION}
// Importing concrete repository from infrastructure

// âœ… CORRECT
// ${APPLICATION_PATH}/GetUsers${FILE_EXTENSION}
// Use interface from domain + dependency injection
\`\`\`

**Fix**: Use interface + dependency injection

### Violation 3: Domain imports anything

\`\`\`${LANGUAGE,,}
// âŒ WRONG
// ${DOMAIN_PATH}/User${FILE_EXTENSION}
// Importing from application layer

// âœ… CORRECT
// ${DOMAIN_PATH}/User${FILE_EXTENSION}
// Pure domain logic, no imports from other layers
\`\`\`

**Fix**: Keep domain pure

---

## Tools for Validation

### Manual Validation (what this playbook does)
- Grep for imports
- Check each layer manually
- Report violations

### Automated Tools (optional)
- Language-specific dependency analyzers
- Custom lint rules
- CI/CD integration

---

## Integration with Commit Workflow

This playbook is called by `.workflow/playbooks/commit.md`:

```
Commit Workflow
  â†’ Step 2.3: Run Architecture Validator
    â†’ Execute: architecture-check.md
    â†’ If fails: Block commit
    â†’ If passes: Continue
```

---

## Checklist for AI Assistants

- [ ] Checked Domain layer (no dependencies)
- [ ] Checked Application layer (domain only)
- [ ] Checked Infrastructure layer (app + domain only)
- [ ] Checked Presentation layer (app + domain only, NOT infra)
- [ ] Generated comprehensive report
- [ ] Provided fixes for each violation
- [ ] Returned correct exit code (0 = pass, 1 = fail)

---

## Notes

- **Presentation â†’ Infrastructure violation is most common**
- Always use interfaces + dependency injection
- DI layer is allowed to wire everything
- Focus on import statements (they reveal dependencies)
- Circular dependencies are also violations
